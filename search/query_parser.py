import re
from typing import List, Optional

# --- Token Definition ---
class Token:
    """Represents a token identified during the lexing phase."""
    def __init__(self, type: str, value: str):
        self.type = type
        self.value = value

    def __repr__(self):
        return f"Token({self.type!r}, {self.value!r})"

# --- Abstract Syntax Tree (AST) Node Definitions ---
class ASTNode:
    """Base class for all AST nodes."""
    pass

class TagNode(ASTNode):
    """Represents a single tag in the query."""
    def __init__(self, tag: str):
        self.tag = tag

    def __repr__(self):
        return f"TagNode({self.tag!r})"

class AndNode(ASTNode):
    """Represents a logical AND operation between two nodes."""
    def __init__(self, left: ASTNode, right: ASTNode):
        self.left = left
        self.right = right

    def __repr__(self):
        return f"AndNode({self.left!r}, {self.right!r})"

class OrNode(ASTNode):
    """Represents a logical OR operation between two nodes."""
    def __init__(self, left: ASTNode, right: ASTNode):
        self.left = left
        self.right = right

    def __repr__(self):
        return f"OrNode({self.left!r}, {self.right!r})"

class NotNode(ASTNode):
    """Represents a logical NOT operation on a node."""
    def __init__(self, node: ASTNode):
        self.node = node

    def __repr__(self):
        return f"NotNode({self.node!r})"

class BracketNode(ASTNode):
    """Represents an expression enclosed in brackets for precedence."""
    def __init__(self, expression: ASTNode):
        self.expression = expression

    def __repr__(self):
        return f"BracketNode({self.expression!r})"

class AllImagesNode(ASTNode):
    """Represents a query for all images (e.g., an empty query string)."""
    # This node might be generated by the parser if the query is empty,
    # or handled separately by the evaluator logic.
    def __repr__(self):
        return "AllImagesNode()"

# --- Search Query Parser ---
class SearchQueryParser:
    """
    Parses a search query string into an Abstract Syntax Tree (AST).
    Treats AND, OR, NOT, [, ] as delimiters. Everything else between
    these delimiters is considered a single tag, allowing spaces without quotes.
    """
    def __init__(self):
        self.tokens: List[Token] = []
        self.current_token: Optional[Token] = None

        # --- NEW: Define delimiters and compile regex patterns ---
        self.delimiters = {
            'AND': r'\bAND\b',
            'OR': r'\bOR\b',
            'NOT': r'\bNOT\b',
            'LBRACKET': r'\[',
            'RBRACKET': r'\]',
        }
        # Compile regex for finding delimiters (case-insensitive for operators)
        self.delimiter_patterns = {
            kind: re.compile(pattern, re.IGNORECASE)
            for kind, pattern in self.delimiters.items()
        }
        # --- END NEW ---

        # --- REMOVED: Old regex-based token specification and get_token ---
        # self.token_specification = [...]
        # self.tok_regex = ...
        # self.get_token = ...
        # --- END REMOVED ---

    # --- NEW: Non-regex based tokenizer ---
    def tokenize(self, query: str) -> List[Token]:
        """
        Converts the input query string into a list of tokens based on
        AND, OR, NOT, [, ] as delimiters.
        """
        print(f"SearchQueryParser: Tokenizing query: '{query}'") # Debug
        self.tokens = []
        pos = 0
        query_len = len(query)

        while pos < query_len:
            # --- 1. Skip leading whitespace ---
            start_pos = pos
            while start_pos < query_len and query[start_pos].isspace():
                start_pos += 1
            # If we reached the end after skipping whitespace, break
            if start_pos == query_len:
                break
            pos = start_pos # Update current position after skipping whitespace

            # --- 2. Find the *next* delimiter ---
            first_match_pos = query_len
            first_match_kind = None
            first_match_end = query_len

            # Search for the earliest occurrence of any delimiter from the current position
            for kind, pattern in self.delimiter_patterns.items():
                match = pattern.search(query, pos)
                if match and match.start() < first_match_pos:
                    first_match_pos = match.start()
                    first_match_kind = kind
                    first_match_end = match.end()

            # --- 3. Extract the tag (if any) before the delimiter ---
            # The tag text is from the current position up to the start of the found delimiter
            tag_text = query[pos:first_match_pos].strip() # Strip whitespace from the tag itself

            # If we found non-whitespace text before the delimiter (or before the end), it's a tag
            if tag_text:
                self.tokens.append(Token('TAG', tag_text))

            # --- 4. Add the delimiter token (if one was found) ---
            if first_match_kind:
                delimiter_value = query[first_match_pos:first_match_end]
                # Use uppercase for operators for consistency in the token type if desired,
                # though the kind already tells us what it is.
                self.tokens.append(Token(first_match_kind, delimiter_value))
                pos = first_match_end # Move position past the delimiter
            else:
                # No more delimiters found, loop will terminate as pos reaches query_len
                # The last tag (if any) was added in step 3.
                pos = query_len

        print(f"SearchQueryParser: Tokens generated: {self.tokens}") # Debug
        return self.tokens
    # --- END NEW ---

    # (Keep next_token method as is)
    def next_token(self):
        """Advances to the next token in the list."""
        if self.tokens:
            self.current_token = self.tokens.pop(0)
        else:
            self.current_token = None # End of tokens
        # print(f"SearchQueryParser: Next token: {self.current_token}") # Debug

    # (Keep parse method as is)
    def parse(self, query: str) -> ASTNode:
        """Parses the tokenized query into an AST."""
        print(f"SearchQueryParser: Parsing query: '{query}'") # Debug
        if not query.strip():
             return AllImagesNode()

        self.tokenize(query) # Uses the NEW tokenize method
        if not self.tokens:
             return AllImagesNode()

        self.next_token()
        result = self.parse_expression()

        if self.current_token is not None:
            # Use the value of the unexpected token in the error message
            raise ValueError(f"Unexpected token at end of query: Token('{self.current_token.type}', '{self.current_token.value}')")


        print(f"SearchQueryParser: Parsed AST: {result!r}") # Debug
        return result

    # --- Recursive Descent Parsing Methods ---
    # (Keep parse_expression and parse_term as is)
    def parse_expression(self) -> ASTNode:
        # print("SearchQueryParser: Parsing expression") # Debug
        node = self.parse_term()
        while self.current_token and self.current_token.type == 'OR':
            self.next_token()
            right_node = self.parse_term()
            node = OrNode(node, right_node)
        return node

    def parse_term(self) -> ASTNode:
        # print("SearchQueryParser: Parsing term") # Debug
        node = self.parse_factor()
        while self.current_token and self.current_token.type == 'AND':
            self.next_token()
            right_node = self.parse_factor()
            node = AndNode(node, right_node)
        return node

    # (Slightly simplify parse_factor as QUOTED_TAG is gone)
    def parse_factor(self) -> ASTNode:
        # print("SearchQueryParser: Parsing factor") # Debug
        token = self.current_token

        if token is None:
             raise ValueError("Unexpected end of query, expected tag, NOT, or bracket.")

        if token.type == 'NOT':
            self.next_token()
            node = self.parse_factor()
            return NotNode(node)
        elif token.type == 'LBRACKET':
            self.next_token()
            node = self.parse_expression()
            if self.current_token and self.current_token.type == 'RBRACKET':
                self.next_token()
                # --- CHANGE: Return BracketNode for clarity/potential future use ---
                # Although currently the evaluator just processes the inner expression,
                # returning an explicit BracketNode is cleaner AST design.
                return BracketNode(node)
                # --- END CHANGE ---
            else:
                raise ValueError("Mismatched brackets: Expected ']'")
        # --- CHANGE: Only handle 'TAG' now ---
        elif token.type == 'TAG':
            tag_value = token.value # Value already stripped by tokenizer
            print(f"SearchQueryParser: Found Tag: '{tag_value}'") # Debug
            self.next_token()
            return TagNode(tag_value)
        # --- END CHANGE ---
        else:
            # Include token details in the error
            raise ValueError(f"Invalid syntax: Unexpected token Token('{token.type}', '{token.value}')")


# --- Example Usage (for testing) ---
# (Keep __main__ block as is for testing)
if __name__ == '__main__':
    parser = SearchQueryParser()
    queries = [
        "tag1",
        "arcueid brunestud", # Multi-word tag
        "tag1 AND tag2",
        "arcueid brunestud AND 1girl", # Multi-word tag with AND
        "tag1 OR tag2",
        "blue sky OR rainy day", # Multi-word tags with OR
        "NOT tag1",
        "NOT long tag with spaces", # Multi-word tag with NOT
        "tag1 AND NOT tag2",
        "simple tag AND NOT another complex tag with spaces",
        "NOT tag1 OR tag2", # NOT applies only to tag1 here
        "[tag1 OR tag2] AND tag3",
        "[simple tag OR another long tag] AND third tag",
        "NOT [tag1 AND tag2]",
        "NOT [complex tag AND another one]",
        "tag1 AND [tag2 OR NOT tag3]",
        "first tag AND [second tag OR NOT third tag with space]",
        "complex-tag:value AND another_tag",
        "tag with [bracket] inside", # Brackets inside tags are now part of the tag
        "tag with AND inside", # AND inside tags is now part of the tag
        "", # Empty query
        "   ", # Whitespace query
        # Error cases (some might behave differently now)
        # "tag1 AND", # Should still raise error (unexpected end)
        # "OR tag1", # Should raise error (unexpected OR)
        # "[tag1 OR tag2", # Should raise error (unmatched bracket)
        # "tag1 ]", # Should raise error (unexpected bracket)
        # "tag1 tag2", # This will now be parsed as a *single* tag "tag1 tag2" - CORRECT according to new rules
    ]

    for q in queries:
        print(f"\nQuery: '{q}'")
        try:
            ast = parser.parse(q)
            print(f"AST: {ast!r}")
        except ValueError as e:
            print(f"Error parsing query: {e}")
        except Exception as e:
             print(f"Unexpected Error: {e}")
             import traceback
             traceback.print_exc()